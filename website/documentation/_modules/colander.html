
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>colander &#8212; CamCOPS 2.2.4 documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/camcops_docs.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CamCOPS 2.2.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for colander</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">decimal</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">translationstring</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">types</span>

<span class="kn">from</span> <span class="nn">iso8601</span> <span class="k">import</span> <span class="n">iso8601</span>

<span class="kn">from</span> <span class="nn">.compat</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">text_</span><span class="p">,</span>
    <span class="n">text_type</span><span class="p">,</span>
    <span class="n">string_types</span><span class="p">,</span>
    <span class="n">xrange</span><span class="p">,</span>
    <span class="n">is_nonstr_iter</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">translationstring</span><span class="o">.</span><span class="n">TranslationStringFactory</span><span class="p">(</span><span class="s1">&#39;colander&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_required</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents a required value in colander-related operations. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;colander.required&gt;&#39;</span>

<span class="n">required</span> <span class="o">=</span> <span class="n">_required</span><span class="p">()</span>
<span class="n">_marker</span> <span class="o">=</span> <span class="n">required</span> <span class="c1"># bw compat</span>

<span class="k">class</span> <span class="nc">_null</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents a null value in colander-related operations. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># py3 compat</span>
    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;colander.null&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;null&#39;</span> <span class="c1"># when unpickled, refers to &quot;null&quot; below (singleton)</span>

<span class="n">null</span> <span class="o">=</span> <span class="n">_null</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">_drop</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents a value that will be dropped from the schema if it</span>
<span class="sd">    is missing during *serialization* or *deserialization*.  Passed as</span>
<span class="sd">    a value to the `missing` or `default` keyword argument</span>
<span class="sd">    of :class:`SchemaNode`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;colander.drop&gt;&#39;</span>

<span class="n">drop</span> <span class="o">=</span> <span class="n">_drop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">msgs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">msgs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">s</span><span class="o">.</span><span class="n">interpolate</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">s</span>

<span class="k">class</span> <span class="nc">UnboundDeferredError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An exception raised by :meth:`SchemaNode.deserialize` when an attempt</span>
<span class="sd">    is made to deserialize a node which has an unbound :class:`deferred`</span>
<span class="sd">    validator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Invalid</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An exception raised by data types and validators indicating that</span>
<span class="sd">    the value for a particular node was not valid.</span>

<span class="sd">    The constructor receives a mandatory ``node`` argument.  This must</span>
<span class="sd">    be an instance of the :class:`colander.SchemaNode` class, or at</span>
<span class="sd">    least something with the same interface.</span>

<span class="sd">    The constructor also receives an optional ``msg`` keyword</span>
<span class="sd">    argument, defaulting to ``None``.  The ``msg`` argument is a</span>
<span class="sd">    freeform field indicating the error circumstance.</span>

<span class="sd">    The constructor additionally may receive an optional ``value``</span>
<span class="sd">    keyword, indicating the value related to the error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">positional</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">messages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return an iterable of error messages for this exception using the</span>
<span class="sd">        ``msg`` attribute of this error node.  If the ``msg`` attribute is</span>
<span class="sd">        iterable, it is returned.  If it is not iterable, and is</span>
<span class="sd">        non-``None``, a single-element list containing the ``msg`` value is</span>
<span class="sd">        returned.  If the value is ``None``, an empty list is returned.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_nonstr_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a child exception; ``exc`` must be an instance of</span>
<span class="sd">        :class:`colander.Invalid` or a subclass.</span>

<span class="sd">        ``pos`` is a value important for accurate error reporting.  If</span>
<span class="sd">        it is provided, it must be an integer representing the</span>
<span class="sd">        position of ``exc`` relative to all other subexceptions of</span>
<span class="sd">        this exception node.  For example, if the exception being</span>
<span class="sd">        added is about the third child of the exception which is</span>
<span class="sd">        ``self``, ``pos`` might be passed as ``3``.</span>

<span class="sd">        If ``pos`` is provided, it will be assigned to the ``pos``</span>
<span class="sd">        attribute of the provided ``exc`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">Positional</span><span class="p">):</span>
            <span class="n">exc</span><span class="o">.</span><span class="n">positional</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exc</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a subexception related to a child node with the</span>
<span class="sd">        message ``msg``. ``name`` must be present in the names of the</span>
<span class="sd">        set of child nodes of this exception&#39;s node; if this is not</span>
<span class="sd">        so, a :exc:`KeyError` is raised.</span>

<span class="sd">        For example, if the exception upon which ``__setitem__`` is</span>
<span class="sd">        called has a node attribute, and that node attribute has</span>
<span class="sd">        children that have the names ``name`` and ``title``, you may</span>
<span class="sd">        successfully call ``__setitem__(&#39;name&#39;, &#39;Bad name&#39;)`` or</span>
<span class="sd">        ``__setitem__(&#39;title&#39;, &#39;Bad title&#39;)``.  But calling</span>
<span class="sd">        ``__setitem__(&#39;wrong&#39;, &#39;whoops&#39;)`` will result in a</span>
<span class="sd">        :exc:`KeyError`.</span>

<span class="sd">        This method is typically only useful if the ``node`` attribute</span>
<span class="sd">        of the exception upon which it is called is a schema node</span>
<span class="sd">        representing a mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A generator which returns each path through the exception</span>
<span class="sd">        graph.  Each path is represented as a tuple of exception</span>
<span class="sd">        nodes.  Within each tuple, the leftmost item will represent</span>
<span class="sd">        the root schema node, the rightmost item will represent the</span>
<span class="sd">        leaf schema node.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">path</span>

            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">def</span> <span class="nf">_keyname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">positional</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;; &#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a dictionary containing a basic</span>
<span class="sd">        (non-language-translated) error report for this exception.</span>

<span class="sd">        If ``translate`` is supplied, it must be a callable taking a</span>
<span class="sd">        translation string as its sole argument and returning a localized,</span>
<span class="sd">        interpolated string.</span>

<span class="sd">        If ``separator`` is supplied, error messages are joined with that.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">()</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">keyparts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">msgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">exc</span><span class="o">.</span><span class="n">msg</span> <span class="ow">and</span> <span class="n">msgs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">messages</span><span class="p">())</span>
                <span class="n">keyname</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">_keyname</span><span class="p">()</span>
                <span class="n">keyname</span> <span class="ow">and</span> <span class="n">keyparts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keyname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">translate</span><span class="p">:</span>
                <span class="n">msgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">translate</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">msgs</span><span class="p">]</span>
            <span class="n">msgs</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">separator</span><span class="p">:</span>
                <span class="n">msgs</span> <span class="o">=</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msgs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span>
            <span class="n">errors</span><span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">keyparts</span><span class="p">)]</span> <span class="o">=</span> <span class="n">msgs</span>
        <span class="k">return</span> <span class="n">errors</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a pretty-formatted string representation of the</span>
<span class="sd">        result of an execution of this exception&#39;s ``asdict`` method&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">UnsupportedFields</span><span class="p">(</span><span class="n">Invalid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception used when schema object detect unknown fields in the</span>
<span class="sd">    cstruct during deserialize.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UnsupportedFields</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">fields</span>


<span class="k">class</span> <span class="nc">All</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Composite validator which succeeds if none of its</span>
<span class="sd">    subvalidators raises an :class:`colander.Invalid` exception&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">validators</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validators</span> <span class="o">=</span> <span class="n">validators</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">excs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">validator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">validators</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">validator</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Invalid</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">excs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">excs</span><span class="p">:</span>
            <span class="n">exc</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[</span><span class="n">exc</span><span class="o">.</span><span class="n">msg</span> <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="n">excs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">excs</span><span class="p">:</span>
                <span class="n">exc</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">exc</span>

<span class="k">class</span> <span class="nc">Any</span><span class="p">(</span><span class="n">All</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Composite validator which succeeds if at least one of its</span>
<span class="sd">    subvalidators does not raise an :class:`colander.Invalid` exception.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Invalid</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validators</span><span class="p">):</span>
                <span class="c1"># At least one validator did not fail:</span>
                <span class="k">return</span>
            <span class="k">raise</span>

<span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which accepts a function and an optional message;</span>
<span class="sd">    the function is called with the ``value`` during validation.</span>

<span class="sd">    If the function returns anything falsy (``None``, ``False``, the</span>
<span class="sd">    empty string, ``0``, an object with a ``__nonzero__`` that returns</span>
<span class="sd">    ``False``, etc) when called during validation, an</span>
<span class="sd">    :exc:`colander.Invalid` exception is raised (validation fails);</span>
<span class="sd">    its msg will be the value of the ``msg`` argument passed to this</span>
<span class="sd">    class&#39; constructor.</span>

<span class="sd">    If the function returns a stringlike object (a ``str`` or</span>
<span class="sd">    ``unicode`` object) that is *not* the empty string , a</span>
<span class="sd">    :exc:`colander.Invalid` exception is raised using the stringlike</span>
<span class="sd">    value returned from the function as the exeption message</span>
<span class="sd">    (validation fails).</span>

<span class="sd">    If the function returns anything *except* a stringlike object</span>
<span class="sd">    object which is truthy (e.g. ``True``, the integer ``1``, an</span>
<span class="sd">    object with a ``__nonzero__`` that returns ``True``, etc), an</span>
<span class="sd">    :exc:`colander.Invalid` exception is *not* raised (validation</span>
<span class="sd">    succeeds).</span>

<span class="sd">    The default value for the ``msg`` when not provided via the</span>
<span class="sd">    constructor is ``Invalid value``.</span>

<span class="sd">    The ``message`` parameter has been deprecated, use ``msg`` instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only one of msg and message can be passed&#39;</span><span class="p">)</span>
        <span class="c1"># Handle bw compat</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">message</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Invalid value&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;The &quot;message&quot; argument has been deprecated, use &quot;msg&quot; &#39;</span>
                <span class="s1">&#39;instead.&#39;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span>
                <span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">translationstring</span><span class="o">.</span><span class="n">TranslationString</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">}))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">translationstring</span><span class="o">.</span><span class="n">TranslationString</span><span class="p">(</span>
                    <span class="n">result</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">}))</span>

<span class="k">class</span> <span class="nc">Regex</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Regular expression validator.</span>

<span class="sd">        Initialize it with the string regular expression ``regex`` that will</span>
<span class="sd">        be compiled and matched against ``value`` when validator is called. It</span>
<span class="sd">        uses Python&#39;s :py:func:`re.match`, which only matches at the beginning</span>
<span class="sd">        of the string and not at the beginning of each line. To match the</span>
<span class="sd">        entire string, enclose the regular expression with ``^`` and ``$``.</span>
<span class="sd">        If ``msg`` is supplied, it will be the error message to be used;</span>
<span class="sd">        otherwise, defaults to &#39;String does not match expected pattern&#39;.</span>

<span class="sd">        The ``regex`` expression behaviour can be modified by specifying</span>
<span class="sd">        any ``flags`` value taken by ``re.compile``.</span>

<span class="sd">        The ``regex`` argument may also be a pattern object (the</span>
<span class="sd">        result of ``re.compile``) instead of a string.</span>

<span class="sd">        When calling, if ``value`` matches the regular expression,</span>
<span class="sd">        validation succeeds; otherwise, :exc:`colander.Invalid` is</span>
<span class="sd">        raised with the ``msg`` error message.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_object</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_object</span> <span class="o">=</span> <span class="n">regex</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;String does not match expected pattern&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_object</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>

<span class="n">EMAIL_RE</span> <span class="o">=</span> <span class="s2">&quot;(?i)^[A-Z0-9._%!#$%&amp;&#39;*+-/=?^_`{|}~()]+@[A-Z0-9]+([.-][A-Z0-9]+)*\.[A-Z]{2,22}$&quot;</span>

<span class="k">class</span> <span class="nc">Email</span><span class="p">(</span><span class="n">Regex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Email address validator. If ``msg`` is supplied, it will be</span>
<span class="sd">        the error message to be used when raising :exc:`colander.Invalid`;</span>
<span class="sd">        otherwise, defaults to &#39;Invalid email address&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">email_regex</span> <span class="o">=</span> <span class="n">text_</span><span class="p">(</span><span class="n">EMAIL_RE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Invalid email address&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Email</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">email_regex</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Range</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which succeeds if the value it is passed is greater</span>
<span class="sd">    or equal to ``min`` and less than or equal to ``max``.  If ``min``</span>
<span class="sd">    is not specified, or is specified as ``None``, no lower bound</span>
<span class="sd">    exists.  If ``max`` is not specified, or is specified as ``None``,</span>
<span class="sd">    no upper bound exists.</span>

<span class="sd">    ``min_err`` is used to form the ``msg`` of the</span>
<span class="sd">    :exc:`colander.Invalid` error when reporting a validation failure</span>
<span class="sd">    caused by a value not meeting the minimum.  If ``min_err`` is</span>
<span class="sd">    specified, it must be a string.  The string may contain the</span>
<span class="sd">    replacement targets ``${min}`` and ``${val}``, representing the</span>
<span class="sd">    minimum value and the provided value respectively.  If it is not</span>
<span class="sd">    provided, it defaults to ``&#39;${val} is less than minimum value</span>
<span class="sd">    ${min}&#39;``.</span>

<span class="sd">    ``max_err`` is used to form the ``msg`` of the</span>
<span class="sd">    :exc:`colander.Invalid` error when reporting a validation failure</span>
<span class="sd">    caused by a value exceeding the maximum.  If ``max_err`` is</span>
<span class="sd">    specified, it must be a string.  The string may contain the</span>
<span class="sd">    replacement targets ``${max}`` and ``${val}``, representing the</span>
<span class="sd">    maximum value and the provided value respectively.  If it is not</span>
<span class="sd">    provided, it defaults to ``&#39;${val} is greater than maximum value</span>
<span class="sd">    ${max}&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_MIN_ERR</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{val}</span><span class="s1"> is less than minimum value $</span><span class="si">{min}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">_MAX_ERR</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{val}</span><span class="s1"> is greater than maximum value $</span><span class="si">{max}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_err</span><span class="o">=</span><span class="n">_MIN_ERR</span><span class="p">,</span> <span class="n">max_err</span><span class="o">=</span><span class="n">_MAX_ERR</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="nb">min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_err</span> <span class="o">=</span> <span class="n">min_err</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_err</span> <span class="o">=</span> <span class="n">max_err</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
                <span class="n">min_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">min_err</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">min_err</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="n">max_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_err</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">max_err</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Length</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validator which succeeds if the value passed to it has a</span>
<span class="sd">        length between a minimum and maximum, expressed in the</span>
<span class="sd">        optional ``min`` and ``max`` arguments.</span>
<span class="sd">        The value can be any sequence, most often a string.</span>

<span class="sd">        If ``min`` is not specified, or is specified as ``None``,</span>
<span class="sd">        no lower bound exists.  If ``max`` is not specified, or</span>
<span class="sd">        is specified as ``None``, no upper bound exists.</span>

<span class="sd">        The default error messages are &quot;Shorter than minimum length ${min}&quot;</span>
<span class="sd">        and &quot;Longer than maximum length ${max}&quot;. These can be customized:</span>

<span class="sd">        ``min_err`` is used to form the ``msg`` of the</span>
<span class="sd">        :exc:`colander.Invalid` error when reporting a validation failure</span>
<span class="sd">        caused by a value not meeting the minimum length.  If ``min_err`` is</span>
<span class="sd">        specified, it must be a string.  The string may contain the</span>
<span class="sd">        replacement target ``${min}``.</span>

<span class="sd">        ``max_err`` is used to form the ``msg`` of the</span>
<span class="sd">        :exc:`colander.Invalid` error when reporting a validation failure</span>
<span class="sd">        caused by a value exceeding the maximum length.  If ``max_err`` is</span>
<span class="sd">        specified, it must be a string.  The string may contain the</span>
<span class="sd">        replacement target ``${max}``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">_MIN_ERR</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Shorter than minimum length $</span><span class="si">{min}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">_MAX_ERR</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Longer than maximum length $</span><span class="si">{max}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_err</span><span class="o">=</span><span class="n">_MIN_ERR</span><span class="p">,</span> <span class="n">max_err</span><span class="o">=</span><span class="n">_MAX_ERR</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="nb">min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_err</span> <span class="o">=</span> <span class="n">min_err</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_err</span> <span class="o">=</span> <span class="n">max_err</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
                <span class="n">min_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_err</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">min_err</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="n">max_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_err</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">max_err</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OneOf</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which succeeds if the value passed to it is one of</span>
<span class="sd">    a fixed set of values &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="p">:</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="p">])</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not one of $</span><span class="si">{choices}</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;choices&#39;</span><span class="p">:</span><span class="n">choices</span><span class="p">})</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NoneOf</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which succeeds if the value passed to it is none of a</span>
<span class="sd">    fixed set of values.</span>

<span class="sd">    ``msg_err`` is used to form the ``msg`` of the :exc:`colander.Invalid`</span>
<span class="sd">    error when reporting a validation failure.  If ``msg_err`` is specified,</span>
<span class="sd">    it must be a string.  The string may contain the replacement targets</span>
<span class="sd">    ``${choices}`` and ``${val}``, representing the set of forbidden values</span>
<span class="sd">    and the provided value respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_MSG_ERR</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; must not be one of $</span><span class="si">{choices}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">msg_err</span><span class="o">=</span><span class="n">_MSG_ERR</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forbidden</span> <span class="o">=</span> <span class="n">choices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_err</span> <span class="o">=</span> <span class="n">msg_err</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forbidden</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">choices</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forbidden</span><span class="p">])</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_err</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="s1">&#39;choices&#39;</span><span class="p">:</span> <span class="n">choices</span><span class="p">})</span>

        <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ContainsOnly</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which succeeds if the value passed to is a sequence and each</span>
<span class="sd">    element in the sequence is also in the sequence passed as ``choices``.</span>
<span class="sd">    This validator is useful when attached to a schemanode with, e.g. a</span>
<span class="sd">    :class:`colander.Set` or another sequencetype.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">err_template</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span>
        <span class="s1">&#39;One or more of the choices you made was not acceptable&#39;</span>
        <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="p">):</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">err_template</span><span class="p">,</span>
                <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;choices&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="p">}</span>
                <span class="p">)</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">luhnok</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which checks to make sure that the value passes a luhn</span>
<span class="sd">    mod-10 checksum (credit cards).  ``value`` must be a string, not an</span>
<span class="sd">    integer.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="n">_luhnok</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                      <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a valid credit card number&#39;</span><span class="p">,</span>
                        <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">}))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                      <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a valid credit card number&#39;</span><span class="p">,</span>
                        <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">}))</span>

<span class="k">def</span> <span class="nf">_luhnok</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">oddeven</span> <span class="o">=</span> <span class="n">num_digits</span> <span class="o">&amp;</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_digits</span><span class="p">):</span>
        <span class="n">digit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span> <span class="n">count</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">^</span> <span class="n">oddeven</span> <span class="p">):</span>
            <span class="n">digit</span> <span class="o">=</span> <span class="n">digit</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">digit</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">digit</span> <span class="o">=</span> <span class="n">digit</span> <span class="o">-</span> <span class="mi">9</span>

        <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">+</span> <span class="n">digit</span>
    <span class="k">return</span> <span class="nb">sum</span>

<span class="n">URL_REGEX</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;(?i)\b((?:[a-z][\w-]+:(?:/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s`!()\[\]</span><span class="si">{}</span><span class="s2">;:&#39;&quot;.,&lt;&gt;?«»“”‘’]))&quot;&quot;&quot;</span> <span class="c1"># &quot;emacs!</span>

<span class="n">url</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="n">URL_REGEX</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Must be a URL&#39;</span><span class="p">))</span>


<span class="n">UUID_REGEX</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;^(?:urn:uuid:)?\{?[a-f0-9]</span><span class="si">{8}</span><span class="s2">(?:-?[a-f0-9]</span><span class="si">{4}</span><span class="s2">)</span><span class="si">{3}</span><span class="s2">-?[a-f0-9]</span><span class="si">{12}</span><span class="s2">\}?$&quot;&quot;&quot;</span>
<span class="n">uuid</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="n">UUID_REGEX</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Invalid UUID string&#39;</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SchemaType</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Base class for all schema types &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">listitem</span><span class="p">:</span>
            <span class="n">selfname</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selfname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">selfname</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">appstruct</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">assert</span> <span class="n">paths</span> <span class="o">==</span> <span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="s2">&quot;paths should be [name] for leaf nodes.&quot;</span>
        <span class="k">return</span> <span class="n">fstruct</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t call &#39;set_value&#39; on a leaf node.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t call &#39;get_value&#39; on a leaf node.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cstruct_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>

<span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type which represents a mapping of names to nodes.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type imply the named keys and values in the mapping.</span>

<span class="sd">    The constructor of this type accepts one extra optional keyword</span>
<span class="sd">    argument that other types do not: ``unknown``.  An attribute of</span>
<span class="sd">    the same name can be set on a type instance to control the</span>
<span class="sd">    behavior after construction.</span>

<span class="sd">    unknown</span>
<span class="sd">        ``unknown`` controls the behavior of this type when an unknown</span>
<span class="sd">        key is encountered in the cstruct passed to the</span>
<span class="sd">        ``deserialize`` method of this instance.  All the potential</span>
<span class="sd">        values of ``unknown`` are strings.  They are:</span>

<span class="sd">        - ``ignore`` means that keys that are not present in the schema</span>
<span class="sd">          associated with this type will be ignored during</span>
<span class="sd">          deserialization.</span>

<span class="sd">        - ``raise`` will cause a :exc:`colander.Invalid` exception to</span>
<span class="sd">          be raised when unknown keys are present in the cstruct</span>
<span class="sd">          during deserialization.</span>

<span class="sd">        - ``preserve`` will preserve the &#39;raw&#39; unknown keys and values</span>
<span class="sd">          in the appstruct returned by deserialization.</span>

<span class="sd">        Default: ``ignore``.</span>

<span class="sd">    Special behavior is exhibited when a subvalue of a mapping is</span>
<span class="sd">    present in the schema but is missing from the mapping passed to</span>
<span class="sd">    either the ``serialize`` or ``deserialize`` method of this class.</span>
<span class="sd">    In this case, the :attr:`colander.null` value will be passed to</span>
<span class="sd">    the ``serialize`` or ``deserialize`` method of the schema node</span>
<span class="sd">    representing the subvalue of the mapping respectively.  During</span>
<span class="sd">    serialization, this will result in the behavior described in</span>
<span class="sd">    :ref:`serializing_null` for the subnode.  During deserialization,</span>
<span class="sd">    this will result in the behavior described in</span>
<span class="sd">    :ref:`deserializing_null` for the subnode.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, a dictionary will be returned, where each of</span>
<span class="sd">    the values in the returned dictionary is the serialized</span>
<span class="sd">    representation of the null value for its type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unknown</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="n">unknown</span>

    <span class="k">def</span> <span class="nf">_set_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="s1">&#39;preserve&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;unknown attribute must be one of &quot;ignore&quot;, &quot;raise&quot;, &#39;</span>
                <span class="s1">&#39;or &quot;preserve&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unknown</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_get_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unknown</span>

    <span class="n">unknown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_unknown</span><span class="p">,</span> <span class="n">_set_unknown</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Does not implement dict-like functionality.&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a mapping type: $</span><span class="si">{err}</span><span class="s1">&#39;</span><span class="p">,</span>
                          <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">})</span>
                          <span class="p">)</span>

    <span class="k">def</span> <span class="nf">cstruct_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">)</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">name</span>
            <span class="n">subval</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_marker</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subval</span> <span class="ow">is</span> <span class="n">_marker</span><span class="p">:</span>
                <span class="n">subval</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">null</span><span class="p">)</span>
            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subval</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">children</span>

    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">name</span>
            <span class="n">subval</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">null</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subval</span> <span class="ow">is</span> <span class="n">drop</span> <span class="ow">or</span> <span class="p">(</span><span class="n">subval</span> <span class="ow">is</span> <span class="n">null</span> <span class="ow">and</span> <span class="n">subnode</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">drop</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sub_result</span> <span class="o">=</span> <span class="n">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Invalid</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">error</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sub_result</span> <span class="ow">is</span> <span class="n">drop</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_result</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnsupportedFields</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                    <span class="n">msg</span><span class="o">=</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Unrecognized keys in mapping: &quot;$</span><span class="si">{val}</span><span class="s1">&quot;&#39;</span><span class="p">,</span>
                          <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">}))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">==</span> <span class="s1">&#39;preserve&#39;</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subappstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">subappstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subcstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">subcstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">listitem</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">selfprefix</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selfprefix</span> <span class="o">=</span> <span class="n">prefix</span>

        <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">name</span>
            <span class="n">substruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">null</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">substruct</span><span class="p">,</span>
                                              <span class="n">prefix</span><span class="o">=</span><span class="n">selfprefix</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_unflatten_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">next_name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">next_name</span><span class="p">]</span>
            <span class="n">next_appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">next_name</span><span class="p">]</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">next_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">next_node</span><span class="p">,</span> <span class="n">next_appstruct</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">appstruct</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Positional</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marker abstract base class meaning &#39;this type has children which</span>
<span class="sd">    should be addressed by position instead of name&#39; (e.g. via seq[0],</span>
<span class="sd">    but never seq[&#39;name&#39;]).  This is consulted by Invalid.asdict when</span>
<span class="sd">    creating a dictionary representation of an error tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Tuple</span><span class="p">(</span><span class="n">Positional</span><span class="p">,</span> <span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type which represents a fixed-length sequence of nodes.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type imply the positional elements of the tuple in the order</span>
<span class="sd">    they are added.</span>

<span class="sd">    This type is willing to serialize and deserialized iterables that,</span>
<span class="sd">    when converted to a tuple, have the same number of elements as the</span>
<span class="sd">    number of the associated node&#39;s subnodes.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not iterable&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                <span class="p">)</span>

        <span class="n">valuelen</span><span class="p">,</span> <span class="n">nodelen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">valuelen</span> <span class="o">!=</span> <span class="n">nodelen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; has an incorrect number of elements &#39;</span>
                  <span class="s1">&#39;(expected $</span><span class="si">{exp}</span><span class="s1">, was $</span><span class="si">{was}</span><span class="s1">)&#39;</span><span class="p">,</span>
                  <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;exp&#39;</span><span class="p">:</span><span class="n">nodelen</span><span class="p">,</span> <span class="s1">&#39;was&#39;</span><span class="p">:</span><span class="n">valuelen</span><span class="p">})</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cstruct_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="n">childlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="n">cstruct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">structlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">structlen</span> <span class="o">&lt;</span> <span class="n">childlen</span><span class="p">:</span>
            <span class="n">missing_children</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">structlen</span><span class="p">:]</span>
            <span class="n">cstruct</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">missing_children</span><span class="p">:</span>
                <span class="n">cstruct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">null</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">structlen</span> <span class="o">&gt;</span> <span class="n">childlen</span><span class="p">:</span>
            <span class="n">cstruct</span> <span class="o">=</span> <span class="n">cstruct</span><span class="p">[:</span><span class="n">childlen</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cstruct</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cstruct</span>

    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">subval</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">Invalid</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">error</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subappstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">subappstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">subval</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">listitem</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">substruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">substruct</span><span class="p">,</span>
                                              <span class="n">prefix</span><span class="o">=</span><span class="n">selfprefix</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="n">mapstruct</span> <span class="o">=</span> <span class="n">_unflatten_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>
        <span class="n">appstruct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">appstruct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapstruct</span><span class="p">[</span><span class="n">subnode</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">appstruct</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">next_name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">next_name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">next_node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">next_name</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">next_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">next_appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">next_node</span><span class="p">,</span> <span class="n">next_appstruct</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">next_node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Set</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a non-overlapping set of items.</span>
<span class="sd">    Deserializes an iterable to a ``set`` object.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    .. versionadded: 1.0a1</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">return</span> <span class="n">appstruct</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonstr_iter</span><span class="p">(</span><span class="n">cstruct</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">_</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{cstruct}</span><span class="s1"> is not iterable&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;cstruct&#39;</span><span class="p">:</span> <span class="n">cstruct</span><span class="p">})</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Type representing an ordered sequence of items.</span>

<span class="sd">    Desrializes an iterable to a ``list`` object.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    .. versionadded: 1.0a6</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">return</span> <span class="n">appstruct</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonstr_iter</span><span class="p">(</span><span class="n">cstruct</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">_</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{cstruct}</span><span class="s1"> is not iterable&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;cstruct&#39;</span><span class="p">:</span> <span class="n">cstruct</span><span class="p">})</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SequenceItems</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List marker subclass for use by Sequence.cstruct_children, which indicates</span>
<span class="sd">    to a caller of that method that the result is from a sequence type.</span>
<span class="sd">    Usually these values need to be treated specially, because all of the</span>
<span class="sd">    children of a Sequence are not present in a schema.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Sequence</span><span class="p">(</span><span class="n">Positional</span><span class="p">,</span> <span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A type which represents a variable-length sequence of nodes,</span>
<span class="sd">    all of which must be of the same type.</span>

<span class="sd">    The type of the first subnode of the</span>
<span class="sd">    :class:`colander.SchemaNode` that wraps this type is considered the</span>
<span class="sd">    sequence type.</span>

<span class="sd">    The optional ``accept_scalar`` argument to this type&#39;s constructor</span>
<span class="sd">    indicates what should happen if the value found during serialization or</span>
<span class="sd">    deserialization does not have an ``__iter__`` method or is a</span>
<span class="sd">    mapping type.</span>

<span class="sd">    If ``accept_scalar`` is ``True`` and the value does not have an</span>
<span class="sd">    ``__iter__`` method or is a mapping type, the value will be turned</span>
<span class="sd">    into a single element list.</span>

<span class="sd">    If ``accept_scalar`` is ``False`` and the value does not have an</span>
<span class="sd">    ``__iter__`` method or is a mapping type, an</span>
<span class="sd">    :exc:`colander.Invalid` error will be raised during serialization</span>
<span class="sd">    and deserialization.</span>

<span class="sd">    The default value of ``accept_scalar`` is ``False``.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accept_scalar</span> <span class="o">=</span> <span class="n">accept_scalar</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">accept_scalar</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not iterable&#39;</span><span class="p">,</span>
                                  <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                         <span class="p">)</span>

    <span class="k">def</span> <span class="nf">cstruct_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SequenceItems</span><span class="p">([])</span>
        <span class="k">return</span> <span class="n">SequenceItems</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">accept_scalar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">accept_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">accept_scalar</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">)</span>

        <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">subnode</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">subval</span> <span class="ow">is</span> <span class="n">drop</span> <span class="ow">or</span> <span class="p">(</span><span class="n">subval</span> <span class="ow">is</span> <span class="n">null</span> <span class="ow">and</span> <span class="n">subnode</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">drop</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sub_result</span> <span class="o">=</span> <span class="n">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Invalid</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">error</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sub_result</span> <span class="ow">is</span> <span class="n">drop</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_result</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Along with the normal ``node`` and ``appstruct`` arguments,</span>
<span class="sd">        this method accepts an additional optional keyword argument:</span>
<span class="sd">        ``accept_scalar``.  This keyword argument can be used to</span>
<span class="sd">        override the constructor value of the same name.</span>

<span class="sd">        If ``accept_scalar`` is ``True`` and the ``appstruct`` does</span>
<span class="sd">        not have an ``__iter__`` method or is a mapping type, the</span>
<span class="sd">        value will be turned into a single element list.</span>

<span class="sd">        If ``accept_scalar`` is ``False`` and the ``appstruct`` does</span>
<span class="sd">        not have an ``__iter__`` method or is a mapping type, an</span>
<span class="sd">        :exc:`colander.Invalid` error will be raised during</span>
<span class="sd">        serialization and deserialization.</span>

<span class="sd">        The default of ``accept_scalar`` is ``None``, which means</span>
<span class="sd">        respect the default ``accept_scalar`` value attached to this</span>
<span class="sd">        instance via its constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subappstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">subappstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Along with the normal ``node`` and ``cstruct`` arguments, this</span>
<span class="sd">        method accepts an additional optional keyword argument:</span>
<span class="sd">        ``accept_scalar``.  This keyword argument can be used to</span>
<span class="sd">        override the constructor value of the same name.</span>

<span class="sd">        If ``accept_scalar`` is ``True`` and the ``cstruct`` does not</span>
<span class="sd">        have an ``__iter__`` method or is a mapping type, the value</span>
<span class="sd">        will be turned into a single element list.</span>

<span class="sd">        If ``accept_scalar`` is ``False`` and the ``cstruct`` does not have an</span>
<span class="sd">        ``__iter__`` method or is a mapping type, an</span>
<span class="sd">        :exc:`colander.Invalid` error will be raised during serialization</span>
<span class="sd">        and deserialization.</span>

<span class="sd">        The default of ``accept_scalar`` is ``None``, which means</span>
<span class="sd">        respect the default ``accept_scalar`` value attached to this</span>
<span class="sd">        instance via its constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subcstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">subcstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">listitem</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">childnode</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">appstruct</span><span class="p">):</span>
            <span class="n">subname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">selfprefix</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="n">subprefix</span> <span class="o">=</span> <span class="n">subname</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">childnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span>
                <span class="n">childnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">subprefix</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="n">only_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">child_name</span> <span class="o">=</span> <span class="n">only_child</span><span class="o">.</span><span class="n">name</span>
        <span class="k">def</span> <span class="nf">get_child</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">only_child</span>
        <span class="k">def</span> <span class="nf">rewrite_subpath</span><span class="p">(</span><span class="n">subpath</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">subpath</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="n">subpath</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">child_name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">child_name</span>
        <span class="n">mapstruct</span> <span class="o">=</span> <span class="n">_unflatten_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">,</span>
                                       <span class="n">get_child</span><span class="p">,</span> <span class="n">rewrite_subpath</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mapstruct</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mapstruct</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">next_name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">next_name</span><span class="p">)</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">next_appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">next_node</span><span class="p">,</span> <span class="n">next_appstruct</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">appstruct</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span>

<span class="n">Seq</span> <span class="o">=</span> <span class="n">Sequence</span>

<span class="k">class</span> <span class="nc">String</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a Unicode string.</span>

<span class="sd">    This type constructor accepts two arguments:</span>

<span class="sd">    ``encoding``</span>
<span class="sd">       Represents the encoding which should be applied to value</span>
<span class="sd">       serialization and deserialization, for example ``utf-8``.  If</span>
<span class="sd">       ``encoding`` is passed as ``None``, the ``serialize`` method of</span>
<span class="sd">       this type will not do any special encoding of the appstruct it is</span>
<span class="sd">       provided, nor will the ``deserialize`` method of this type do</span>
<span class="sd">       any special decoding of the cstruct it is provided; inputs and</span>
<span class="sd">       outputs will be assumed to be Unicode.  ``encoding`` defaults</span>
<span class="sd">       to ``None``.</span>

<span class="sd">       If ``encoding`` is ``None``:</span>

<span class="sd">       - A Unicode input value to ``serialize`` is returned untouched.</span>

<span class="sd">       - A non-Unicode input value to ``serialize`` is run through the</span>
<span class="sd">         ``unicode()`` function without an ``encoding`` parameter</span>
<span class="sd">         (``unicode(value)``) and the result is returned.</span>

<span class="sd">       - A Unicode input value to ``deserialize`` is returned untouched.</span>

<span class="sd">       - A non-Unicode input value to ``deserialize`` is run through the</span>
<span class="sd">         ``unicode()`` function without an ``encoding`` parameter</span>
<span class="sd">         (``unicode(value)``) and the result is returned.</span>

<span class="sd">       If ``encoding`` is not ``None``:</span>

<span class="sd">       - A Unicode input value to ``serialize`` is run through the</span>
<span class="sd">         ``unicode`` function with the encoding parameter</span>
<span class="sd">         (``unicode(value, encoding)``) and the result (a ``str``</span>
<span class="sd">         object) is returned.</span>

<span class="sd">       - A non-Unicode input value to ``serialize`` is converted to a</span>
<span class="sd">         Unicode using the encoding (``unicode(value, encoding)``);</span>
<span class="sd">         subsequently the Unicode object is re-encoded to a ``str``</span>
<span class="sd">         object using the encoding and returned.</span>

<span class="sd">       - A Unicode input value to ``deserialize`` is returned</span>
<span class="sd">         untouched.</span>

<span class="sd">       - A non-Unicode input value to ``deserialize`` is converted to</span>
<span class="sd">         a ``str`` object using ``str(value``).  The resulting str</span>
<span class="sd">         value is converted to Unicode using the encoding</span>
<span class="sd">         (``unicode(value, encoding)``) and the result is returned.</span>

<span class="sd">       A corollary: If a string (as opposed to a unicode object) is</span>
<span class="sd">       provided as a value to either the serialize or deserialize</span>
<span class="sd">       method of this type, and the type also has an non-None</span>
<span class="sd">       ``encoding``, the string must be encoded with the type&#39;s</span>
<span class="sd">       encoding.  If this is not true, an :exc:`colander.Invalid`</span>
<span class="sd">       error will result.</span>

<span class="sd">    ``allow_empty``</span>
<span class="sd">       Boolean, if True allows deserialization of an empty string. If</span>
<span class="sd">       False (default), empty strings will deserialize to</span>
<span class="sd">       :attr:`colander.null`</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_empty</span> <span class="o">=</span> <span class="n">allow_empty</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span>
                <span class="k">if</span> <span class="n">encoding</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">text_</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">text_type</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">text_type</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{val}</span><span class="s1"> cannot be serialized: $</span><span class="si">{err}</span><span class="s1">&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">})</span>
                          <span class="p">)</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cstruct</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">text_</span><span class="p">(</span><span class="n">cstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">text_type</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{val}</span><span class="s1"> is not a string: $</span><span class="si">{err}</span><span class="s1">&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">}))</span>

        <span class="k">return</span> <span class="n">result</span>

<span class="n">Str</span> <span class="o">=</span> <span class="n">String</span>

<span class="k">class</span> <span class="nc">Number</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Abstract base class for float, int, decimal &quot;&quot;&quot;</span>

    <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="n">appstruct</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a number&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">}),</span>
                          <span class="p">)</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a number&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">})</span>
                          <span class="p">)</span>

<span class="k">class</span> <span class="nc">Integer</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing an integer.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span>

<span class="n">Int</span> <span class="o">=</span> <span class="n">Integer</span>

<span class="k">class</span> <span class="nc">Float</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a float.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span>

<span class="k">class</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A type representing a decimal floating point.  Deserialization returns an</span>
<span class="sd">    instance of the Python ``decimal.Decimal`` type.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The Decimal constructor takes three optional arguments, ``quant``,</span>
<span class="sd">    ``rounding`` and ``normalize``.  If supplied, ``quant`` should be a string,</span>
<span class="sd">    (e.g. ``1.00``).  If supplied, ``rounding`` should be one of the Python</span>
<span class="sd">    ``decimal`` module rounding options (e.g. ``decimal.ROUND_UP``,</span>
<span class="sd">    ``decimal.ROUND_DOWN``, etc).  The serialized and deserialized result</span>
<span class="sd">    will be quantized and rounded via</span>
<span class="sd">    ``result.quantize(decimal.Decimal(quant), rounding)``.  ``rounding`` is</span>
<span class="sd">    ignored if ``quant`` is not supplied.  If ``normalize`` is ``True``,</span>
<span class="sd">    the serialized and deserialized result will be normalized by stripping</span>
<span class="sd">    the rightmost trailing zeros.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">quant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="n">quant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">rounding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>

    <span class="k">def</span> <span class="nf">num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">class</span> <span class="nc">Money</span><span class="p">(</span><span class="n">Decimal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a money value with two digit precision.</span>
<span class="sd">    Deserialization returns an instance of the Python ``decimal.Decimal``</span>
<span class="sd">    type (quantized to two decimal places, rounded up).</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Money</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;.01&#39;</span><span class="p">),</span> <span class="n">decimal</span><span class="o">.</span><span class="n">ROUND_UP</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Boolean</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a boolean object.</span>

<span class="sd">    The constructor accepts these keyword arguments:</span>

<span class="sd">    - ``false_choices``: The set of strings representing a ``False``</span>
<span class="sd">      value on deserialization.</span>

<span class="sd">    - ``true_choices``:  The set of strings representing a ``True``</span>
<span class="sd">      value on deserialization.</span>

<span class="sd">    - ``false_val``: The value returned on serialization of a False</span>
<span class="sd">      value.</span>

<span class="sd">    - ``true_val``: The value returned on serialization of a True</span>
<span class="sd">      value.</span>

<span class="sd">    During deserialization, a value contained in :attr:`false_choices`,</span>
<span class="sd">    will be considered ``False``.</span>

<span class="sd">    The behaviour for values not contained in :attr:`false_choices`</span>
<span class="sd">    depends on :attr:`true_choices`: if it&#39;s empty, any value is considered</span>
<span class="sd">    ``True``; otherwise, only values contained in :attr:`true_choices`</span>
<span class="sd">    are considered ``True``, and an Invalid exception would be raised</span>
<span class="sd">    for values outside of both :attr:`false_choices` and :attr:`true_choices`.</span>

<span class="sd">    Serialization will produce :attr:`true_val` or :attr:`false_val`</span>
<span class="sd">    based on the value.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">false_choices</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;false&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">true_choices</span><span class="o">=</span><span class="p">(),</span>
                 <span class="n">false_val</span><span class="o">=</span><span class="s1">&#39;false&#39;</span><span class="p">,</span> <span class="n">true_val</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">false_choices</span> <span class="o">=</span> <span class="n">false_choices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">true_choices</span> <span class="o">=</span> <span class="n">true_choices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">false_val</span> <span class="o">=</span> <span class="n">false_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">true_val</span> <span class="o">=</span> <span class="n">true_val</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">true_reprs</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_choices</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">false_reprs</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_choices</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">return</span> <span class="n">appstruct</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_val</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_val</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;$</span><span class="si">{val}</span><span class="s1"> is not a string&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">})</span>
                          <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_choices</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_choices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_choices</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                              <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is neither in ($</span><span class="si">{false_choices}</span><span class="s1">) &#39;</span>
                                <span class="s1">&#39;nor in ($</span><span class="si">{true_choices}</span><span class="s1">)&#39;</span><span class="p">,</span>
                                <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span>
                                         <span class="s1">&#39;false_choices&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_reprs</span><span class="p">,</span>
                                         <span class="s1">&#39;true_choices&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_reprs</span> <span class="p">})</span>
                              <span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

<span class="n">Bool</span> <span class="o">=</span> <span class="n">Boolean</span>

<span class="k">class</span> <span class="nc">GlobalObject</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing an importable Python object.  This type</span>
<span class="sd">    serializes &#39;global&#39; Python objects (objects which can be imported)</span>
<span class="sd">    to dotted Python names.</span>

<span class="sd">    Two dotted name styles are supported during deserialization:</span>

<span class="sd">    - ``pkg_resources``-style dotted names where non-module attributes</span>
<span class="sd">      of a module are separated from the rest of the path using a &#39;:&#39;</span>
<span class="sd">      e.g. ``package.module:attr``.</span>

<span class="sd">    - ``zope.dottedname``-style dotted names where non-module</span>
<span class="sd">      attributes of a module are separated from the rest of the path</span>
<span class="sd">      using a &#39;.&#39; e.g. ``package.module.attr``.</span>

<span class="sd">    These styles can be used interchangeably.  If the serialization</span>
<span class="sd">    contains a ``:`` (colon), the ``pkg_resources`` resolution</span>
<span class="sd">    mechanism will be chosen, otherwise the ``zope.dottedname``</span>
<span class="sd">    resolution mechanism will be chosen.</span>

<span class="sd">    The constructor accepts a single argument named ``package`` which</span>
<span class="sd">    should be a Python module or package object; it is used when</span>
<span class="sd">    *relative* dotted names are supplied to the ``deserialize``</span>
<span class="sd">    method.  A serialization which has a ``.`` (dot) or ``:`` (colon)</span>
<span class="sd">    as its first character is treated as relative.  E.g. if</span>
<span class="sd">    ``.minidom`` is supplied to ``deserialize``, and the ``package``</span>
<span class="sd">    argument to this type was passed the ``xml`` module object, the</span>
<span class="sd">    resulting import would be for ``xml.minidom``.  If a relative</span>
<span class="sd">    package name is supplied to ``deserialize``, and no ``package``</span>
<span class="sd">    was supplied to the constructor, an :exc:`colander.Invalid` error</span>
<span class="sd">    will be raised.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">package</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">package</span> <span class="o">=</span> <span class="n">package</span>

    <span class="k">def</span> <span class="nf">_pkg_resources_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; package.module:attr style &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pkg_resources</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">(</span><span class="s1">&#39;relative name &quot;$</span><span class="si">{val}</span><span class="s1">&quot; irresolveable without package&#39;</span><span class="p">,</span>
                      <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">]:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">EntryPoint</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span>
            <span class="s1">&#39;x=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_zope_dottedname_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; package.module.attr style &quot;&quot;&quot;</span>
        <span class="n">module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">(</span><span class="s1">&#39;relative name &quot;$</span><span class="si">{val}</span><span class="s1">&quot; irresolveable without package&#39;</span><span class="p">,</span>
                      <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                    <span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                        <span class="n">node</span><span class="p">,</span>
                        <span class="n">_</span><span class="p">(</span><span class="s1">&#39;relative name &quot;$</span><span class="si">{val}</span><span class="s1">&quot; irresolveable without &#39;</span>
                          <span class="s1">&#39;package&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                        <span class="p">)</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                <span class="n">name</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">name</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">module</span> <span class="o">+</span> <span class="n">name</span>

        <span class="n">used</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">found</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">used</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">used</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">n</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
                <span class="nb">__import__</span><span class="p">(</span><span class="n">used</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">found</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">appstruct</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0.__module__}</span><span class="s1">.</span><span class="si">{0.__name__}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>
            
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; has no __name__&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">})</span>
                          <span class="p">)</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cstruct</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a string&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">}))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">cstruct</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pkg_resources_style</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zope_dottedname_style</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;The dotted name &quot;$</span><span class="si">{name}</span><span class="s1">&quot; cannot be imported&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">}))</span>

<span class="k">class</span> <span class="nc">DateTime</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a Python ``datetime.datetime`` object.</span>

<span class="sd">    This type serializes python ``datetime.datetime`` objects to a</span>
<span class="sd">    `ISO8601 &lt;http://en.wikipedia.org/wiki/ISO_8601&gt;`_ string format.</span>
<span class="sd">    The format includes the date, the time, and the timezone of the</span>
<span class="sd">    datetime.</span>

<span class="sd">    The constructor accepts an argument named ``default_tzinfo`` which</span>
<span class="sd">    should be a Python ``tzinfo`` object. If ``default_tzinfo`` is not</span>
<span class="sd">    specified the default tzinfo will be equivalent to UTC (Zulu time).</span>
<span class="sd">    The ``default_tzinfo`` tzinfo object is used to convert &#39;naive&#39;</span>
<span class="sd">    datetimes to a timezone-aware representation during serialization.</span>
<span class="sd">    If ``default_tzinfo`` is explicitly set to ``None`` then no default</span>
<span class="sd">    tzinfo will be applied to naive datetimes.</span>

<span class="sd">    You can adjust the error message reported by this class by</span>
<span class="sd">    changing its ``err_template`` attribute in a subclass on an</span>
<span class="sd">    instance of this class.  By default, the ``err_template``</span>
<span class="sd">    attribute is the string ``Invalid date``.  This string is used as</span>
<span class="sd">    the interpolation subject of a dictionary composed of ``val`` and</span>
<span class="sd">    ``err``.  ``val`` and ``err`` are the unvalidatable value and the</span>
<span class="sd">    exception caused trying to convert the value, respectively. These</span>
<span class="sd">    may be used in an overridden err_template as ``${val}`` and</span>
<span class="sd">    ``${err}`` respectively as necessary, e.g. ``_(&#39;${val} cannot be</span>
<span class="sd">    parsed as an iso8601 date: ${err}&#39;)``.</span>

<span class="sd">    For convenience, this type is also willing to coerce</span>
<span class="sd">    ``datetime.date`` objects to a DateTime ISO string representation</span>
<span class="sd">    during serialization.  It does so by using midnight of the day as</span>
<span class="sd">    the time, and uses the ``default_tzinfo`` to give the</span>
<span class="sd">    serialization a timezone.</span>

<span class="sd">    Likewise, for convenience, during deserialization, this type will</span>
<span class="sd">    convert ``YYYY-MM-DD`` ISO8601 values to a datetime object.  It</span>
<span class="sd">    does so by using midnight of the day as the time, and uses the</span>
<span class="sd">    ``default_tzinfo`` to give the serialization a timezone.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">err_template</span> <span class="o">=</span>  <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Invalid date&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_tzinfo</span><span class="o">=</span><span class="n">iso8601</span><span class="o">.</span><span class="n">UTC</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_tzinfo</span> <span class="o">=</span> <span class="n">default_tzinfo</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">appstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span> <span class="ow">is</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">:</span> <span class="c1"># cant use isinstance; dt subs date</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a datetime object&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">})</span>
                          <span class="p">)</span>

        <span class="k">if</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_tzinfo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">parse_date</span><span class="p">(</span>
                <span class="n">cstruct</span><span class="p">,</span> <span class="n">default_timezone</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_tzinfo</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">ParseError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_template</span><span class="p">,</span>
                                  <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">}))</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">class</span> <span class="nc">Date</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a Python ``datetime.date`` object.</span>

<span class="sd">    This type serializes python ``datetime.date`` objects to a</span>
<span class="sd">    `ISO8601 &lt;http://en.wikipedia.org/wiki/ISO_8601&gt;`_ string format.</span>
<span class="sd">    The format includes the date only.</span>

<span class="sd">    The constructor accepts no arguments.</span>

<span class="sd">    You can adjust the error message reported by this class by</span>
<span class="sd">    changing its ``err_template`` attribute in a subclass on an</span>
<span class="sd">    instance of this class.  By default, the ``err_template``</span>
<span class="sd">    attribute is the string ``Invalid date``.  This string is used as</span>
<span class="sd">    the interpolation subject of a dictionary composed of ``val`` and</span>
<span class="sd">    ``err``.  ``val`` and ``err`` are the unvalidatable value and the</span>
<span class="sd">    exception caused trying to convert the value, respectively. These</span>
<span class="sd">    may be used in an overridden err_template as ``${val}`` and</span>
<span class="sd">    ``${err}`` respectively as necessary, e.g. ``_(&#39;${val} cannot be</span>
<span class="sd">    parsed as an iso8601 date: ${err}&#39;)``.</span>

<span class="sd">    For convenience, this type is also willing to coerce</span>
<span class="sd">    ``datetime.datetime`` objects to a date-only ISO string</span>
<span class="sd">    representation during serialization.  It does so by stripping off</span>
<span class="sd">    any time information, converting the ``datetime.datetime`` into a</span>
<span class="sd">    date before serializing.</span>

<span class="sd">    Likewise, for convenience, this type is also willing to coerce ISO</span>
<span class="sd">    representations that contain time info into a ``datetime.date``</span>
<span class="sd">    object during deserialization.  It does so by throwing away any</span>
<span class="sd">    time information related to the serialized value during</span>
<span class="sd">    deserialization.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">err_template</span> <span class="o">=</span>  <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Invalid date&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">appstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a date object&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">})</span>
                          <span class="p">)</span>

        <span class="k">return</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">parse_date</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">ParseError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_template</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">})</span>
                          <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">class</span> <span class="nc">Time</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a Python ``datetime.time`` object.</span>

<span class="sd">    .. note:: This type is new as of Colander 0.9.3.</span>

<span class="sd">    This type serializes python ``datetime.time`` objects to a</span>
<span class="sd">    `ISO8601 &lt;http://en.wikipedia.org/wiki/ISO_8601&gt;`_ string format.</span>
<span class="sd">    The format includes the time only.</span>

<span class="sd">    The constructor accepts no arguments.</span>

<span class="sd">    You can adjust the error message reported by this class by</span>
<span class="sd">    changing its ``err_template`` attribute in a subclass on an</span>
<span class="sd">    instance of this class.  By default, the ``err_template``</span>
<span class="sd">    attribute is the string ``Invalid date``.  This string is used as</span>
<span class="sd">    the interpolation subject of a dictionary composed of ``val`` and</span>
<span class="sd">    ``err``.  ``val`` and ``err`` are the unvalidatable value and the</span>
<span class="sd">    exception caused trying to convert the value, respectively. These</span>
<span class="sd">    may be used in an overridden err_template as ``${val}`` and</span>
<span class="sd">    ``${err}`` respectively as necessary, e.g. ``_(&#39;${val} cannot be</span>
<span class="sd">    parsed as an iso8601 date: ${err}&#39;)``.</span>

<span class="sd">    For convenience, this type is also willing to coerce</span>
<span class="sd">    ``datetime.datetime`` objects to a time-only ISO string</span>
<span class="sd">    representation during serialization.  It does so by stripping off</span>
<span class="sd">    any date information, converting the ``datetime.datetime`` into a</span>
<span class="sd">    time before serializing.</span>

<span class="sd">    Likewise, for convenience, this type is also willing to coerce ISO</span>
<span class="sd">    representations that contain time info into a ``datetime.time``</span>
<span class="sd">    object during deserialization.  It does so by throwing away any</span>
<span class="sd">    date information related to the serialized value during</span>
<span class="sd">    deserialization.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">err_template</span> <span class="o">=</span>  <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Invalid time&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">appstruct</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">null</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s1">&#39;&quot;$</span><span class="si">{val}</span><span class="s1">&quot; is not a time object&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">})</span>
                          <span class="p">)</span>

        <span class="k">return</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">parse_date</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">iso8601</span><span class="o">.</span><span class="n">ParseError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">timeparse</span><span class="p">(</span><span class="n">cstruct</span><span class="p">,</span> <span class="s1">&#39;%H:%M:%S&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">timeparse</span><span class="p">(</span><span class="n">cstruct</span><span class="p">,</span> <span class="s1">&#39;%H:%M&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                                  <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_template</span><span class="p">,</span>
                                    <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">})</span>
                                  <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">timeparse</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">format</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">format</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_add_node_children</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
        <span class="n">insert_before</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;insert_before&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">exists</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_marker</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_marker</span>
        <span class="c1"># use exists for microspeed; we could just call __setitem__</span>
        <span class="c1"># exclusively, but it does an enumeration that&#39;s unnecessary in the</span>
        <span class="c1"># common (nonexisting) case (.add is faster)</span>
        <span class="k">if</span> <span class="n">insert_before</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                <span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">node</span><span class="o">.</span><span class="n">add_before</span><span class="p">(</span><span class="n">insert_before</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_SchemaNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fundamental building block of schemas.</span>

<span class="sd">    The constructor accepts these positional arguments:</span>

<span class="sd">    - ``typ``: The &#39;type&#39; for this node.  It should be an</span>
<span class="sd">      instance of a class that implements the</span>
<span class="sd">      :class:`colander.interfaces.Type` interface.  If ``typ`` is not passed,</span>
<span class="sd">      a call to the ``schema_type()`` method on this class is made to</span>
<span class="sd">      get a default type.  (When subclassing, ``schema_type()`` should</span>
<span class="sd">      be overridden to provide a reasonable default type).</span>

<span class="sd">    - ``*children``: a sequence of subnodes.  If the subnodes of this</span>
<span class="sd">      node are not known at construction time, they can later be added</span>
<span class="sd">      via the ``add`` method.</span>

<span class="sd">    The constructor accepts these keyword arguments:</span>

<span class="sd">    - ``name``: The name of this node.</span>

<span class="sd">    - ``typ``: The &#39;type&#39; for this node can optionally be passed in as a</span>
<span class="sd">      keyword argument. See the documentation for the positional arg above.</span>

<span class="sd">    - ``default``: The default serialization value for this node when</span>
<span class="sd">      not set.  If ``default`` is :attr:`colander.drop`, the node</span>
<span class="sd">      will be dropped from schema serialization.  If not provided,</span>
<span class="sd">      the node will be serialized to :attr:`colander.null`.</span>

<span class="sd">    - ``missing``: The default deserialization value for this node.  If it is</span>
<span class="sd">      not provided, the missing value of this node will be the special marker</span>
<span class="sd">      value :attr:`colander.required`, indicating that it is considered</span>
<span class="sd">      &#39;required&#39;.  When ``missing`` is :attr:`colander.required`, the</span>
<span class="sd">      ``required`` computed attribute will be ``True``.  When ``missing`` is</span>
<span class="sd">      :attr:`colander.drop`, the node is dropped from the schema if it isn&#39;t</span>
<span class="sd">      set during deserialization.</span>

<span class="sd">    - ``missing_msg``: Optional error message to be used if the value is</span>
<span class="sd">      required and missing.</span>

<span class="sd">    - ``preparer``: Optional preparer for this node.  It should be</span>
<span class="sd">      an object that implements the</span>
<span class="sd">      :class:`colander.interfaces.Preparer` interface.</span>

<span class="sd">    - ``validator``: Optional validator for this node.  It should be</span>
<span class="sd">      an object that implements the</span>
<span class="sd">      :class:`colander.interfaces.Validator` interface.</span>

<span class="sd">    - ``after_bind``: A callback which is called after a clone of this</span>
<span class="sd">      node has &#39;bound&#39; all of its values successfully. This callback</span>
<span class="sd">      is useful for performing arbitrary actions to the cloned node,</span>
<span class="sd">      or direct children of the cloned node (such as removing or</span>
<span class="sd">      adding children) at bind time.  A &#39;binding&#39; is the result of an</span>
<span class="sd">      execution of the ``bind`` method of the clone&#39;s prototype node,</span>
<span class="sd">      or one of the parents of the clone&#39;s prototype nodes.  The</span>
<span class="sd">      deepest nodes in the node tree are bound first, so the</span>
<span class="sd">      ``after_bind`` methods of the deepest nodes are called before</span>
<span class="sd">      the shallowest.  The ``after_bind`` callback should</span>
<span class="sd">      accept two values: ``node`` and ``kw``.  ``node`` will be a</span>
<span class="sd">      clone of the bound node object, ``kw`` will be the set of</span>
<span class="sd">      keywords passed to the ``bind`` method.</span>

<span class="sd">    - ``title``: The title of this node.  Defaults to a titleization</span>
<span class="sd">      of the ``name`` (underscores replaced with empty strings and the</span>
<span class="sd">      first letter of every resulting word capitalized).  The title is</span>
<span class="sd">      used by higher-level systems (not by Colander itself).</span>

<span class="sd">    - ``description``: The description for this node.  Defaults to</span>
<span class="sd">      ``&#39;&#39;`` (the empty string).  The description is used by</span>
<span class="sd">      higher-level systems (not by Colander itself).</span>

<span class="sd">    - ``widget``: The &#39;widget&#39; for this node.  Defaults to ``None``.</span>
<span class="sd">      The widget attribute is not interpreted by Colander itself, it</span>
<span class="sd">      is only meaningful to higher-level systems such as Deform.</span>
<span class="sd">    </span>
<span class="sd">    - ``insert_before``: if supplied, it names a sibling defined by a </span>
<span class="sd">      superclass for its parent node; the current node will be inserted </span>
<span class="sd">      before the named node. It is not useful unless a mapping schema is </span>
<span class="sd">      inherited from another mapping schema, and you need to control </span>
<span class="sd">      the ordering of the resulting nodes.</span>
<span class="sd">      </span>
<span class="sd">    Arbitrary keyword arguments remaining will be attached to the node</span>
<span class="sd">    object unmolested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_counter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="n">preparer</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">validator</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">default</span> <span class="o">=</span> <span class="n">null</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="n">required</span>
    <span class="n">missing_msg</span> <span class="o">=</span> <span class="s1">&#39;Required&#39;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">raw_title</span> <span class="o">=</span> <span class="n">_marker</span>  <span class="c1"># only changes if title is explicitly set</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">_marker</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">widget</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">after_bind</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bindings</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_counter</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_add_node_children</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__all_schema_nodes__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># bw compat forces us to treat first arg as type if not a _SchemaNode</span>
        <span class="k">if</span> <span class="s1">&#39;typ&#39;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;typ&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">arg</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_SchemaNode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema_type</span><span class="p">()</span>
        <span class="n">_add_node_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

        <span class="c1"># bw compat forces us to manufacture a title if one is not supplied</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="n">_marker</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;raw_title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">title</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">schema_type</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Schema node construction without a `typ` argument or &#39;</span>
            <span class="s1">&#39;a schema_type() callable present on the node class &#39;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">required</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A property which returns ``True`` if the ``missing`` value</span>
<span class="sd">        related to this node was not specified.</span>

<span class="sd">        A return value of ``True`` implies that a ``missing`` value wasn&#39;t</span>
<span class="sd">        specified for this node or that the ``missing`` value of this node is</span>
<span class="sd">        :attr:`colander.required`.  A return value of ``False`` implies that</span>
<span class="sd">        a &#39;real&#39; ``missing`` value was specified for this node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span>  <span class="c1"># unbound schema with deferreds</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="ow">is</span> <span class="n">required</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="o">=</span><span class="n">null</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Serialize the :term:`appstruct` to a :term:`cstruct` based</span>
<span class="sd">        on the schema represented by this node and return the</span>
<span class="sd">        cstruct.</span>

<span class="sd">        If ``appstruct`` is :attr:`colander.null`, return the</span>
<span class="sd">        serialized value of this node&#39;s ``default`` attribute (by</span>
<span class="sd">        default, the serialization of :attr:`colander.null`).</span>

<span class="sd">        If an ``appstruct`` argument is not explicitly provided, it</span>
<span class="sd">        defaults to :attr:`colander.null`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span> <span class="c1"># unbound schema with deferreds</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">null</span>
        <span class="n">cstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cstruct</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create and return a data structure which is a flattened</span>
<span class="sd">        representation of the passed in struct based on the schema represented</span>
<span class="sd">        by this node.  The return data structure is a dictionary; its keys are</span>
<span class="sd">        dotted names.  Each dotted name represents a path to a location in the</span>
<span class="sd">        schema.  The values of of the flattened dictionary are subvalues of</span>
<span class="sd">        the passed in struct.&quot;&quot;&quot;</span>
        <span class="n">flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flat</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create and return a data structure with nested substructures based</span>
<span class="sd">        on the schema represented by this node using the flattened</span>
<span class="sd">        representation passed in. This is the inverse operation to</span>
<span class="sd">        :meth:`colander.SchemaNode.flatten`.&quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fstruct</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">dotted_name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Uses the schema to set a value in a nested datastructure from a</span>
<span class="sd">        dotted name path. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">dotted_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">dotted_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Traverses the nested data structure using the schema and retrieves</span>
<span class="sd">        the value specified by the dotted name path.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">dotted_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cstruct</span><span class="o">=</span><span class="n">null</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Deserialize the :term:`cstruct` into an :term:`appstruct` based</span>
<span class="sd">        on the schema, run this :term:`appstruct` through the</span>
<span class="sd">        preparer, if one is present, then validate the</span>
<span class="sd">        prepared appstruct.  The ``cstruct`` value is deserialized into an</span>
<span class="sd">        ``appstruct`` unconditionally.</span>

<span class="sd">        If ``appstruct`` returned by type deserialization and</span>
<span class="sd">        preparation is the value :attr:`colander.null`, do something</span>
<span class="sd">        special before attempting validation:</span>

<span class="sd">        - If the ``missing`` attribute of this node has been set explicitly,</span>
<span class="sd">          return its value.  No validation of this value is performed; it is</span>
<span class="sd">          simply returned.</span>

<span class="sd">        - If the ``missing`` attribute of this node has not been set</span>
<span class="sd">          explicitly, raise a :exc:`colander.Invalid` exception error.</span>

<span class="sd">        If the appstruct is not ``colander.null`` and cannot be validated , a</span>
<span class="sd">        :exc:`colander.Invalid` exception will be raised.</span>

<span class="sd">        If a ``cstruct`` argument is not explicitly provided, it</span>
<span class="sd">        defaults to :attr:`colander.null`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">appstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preparer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if the preparer is a function, call a single preparer</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preparer</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="n">appstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preparer</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>
            <span class="c1"># if the preparer is a list, call each separate preparer</span>
            <span class="k">elif</span> <span class="n">is_nonstr_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preparer</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">preparer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preparer</span><span class="p">:</span>
                    <span class="n">appstruct</span> <span class="o">=</span> <span class="n">preparer</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span>
            <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">required</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_msg</span><span class="p">,</span>
                                      <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                                               <span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">}))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span> <span class="c1"># unbound schema with deferreds</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_msg</span><span class="p">)</span>
            <span class="c1"># We never deserialize or validate the missing value</span>
            <span class="k">return</span> <span class="n">appstruct</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span> <span class="c1"># unbound</span>
                <span class="k">raise</span> <span class="n">UnboundDeferredError</span><span class="p">(</span>
                    <span class="s2">&quot;Schema node </span><span class="si">{node}</span><span class="s2"> has an unbound deferred validator&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Append a subnode to this node. ``node`` must be a SchemaNode.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Insert a subnode into the position ``index``.  ``node`` must be</span>
<span class="sd">        a SchemaNode.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Insert a subnode into the position before the node named ``name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">sub</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[:]):</span>
            <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;No such node named </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the subnode associated with ``name`` or ``default`` if no</span>
<span class="sd">        such node exists.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clone the schema node and return the clone.  All subnodes</span>
<span class="sd">        are also cloned recursively.  Attributes present in node</span>
<span class="sd">        dictionaries are preserved.&quot;&quot;&quot;</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
        <span class="n">cloned</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Resolve any deferred values attached to this schema node</span>
<span class="sd">        and its children (recursively), using the keywords passed as</span>
<span class="sd">        ``kw`` as input to each deferred value.  This function</span>
<span class="sd">        *clones* the schema it is called upon and returns the cloned</span>
<span class="sd">        value.  The original schema node (the source of the clone)</span>
<span class="sd">        is not modified.&quot;&quot;&quot;</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="k">def</span> <span class="nf">_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span> <span class="o">=</span> <span class="n">kw</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">SchemaNode</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;after_bind&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">after_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cstruct_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Will call the node&#39;s type&#39;s ``cstruct_children`` method with this</span>
<span class="sd">        node as a first argument, and ``cstruct`` as a second argument.&quot;&quot;&quot;</span>
        <span class="n">cstruct_children</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="s1">&#39;cstruct_children&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cstruct_children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;The node type </span><span class="si">%s</span><span class="s1"> has no cstruct_children method.&#39;</span>
                <span class="s1">&#39;This method is required to be implemented by schema types for &#39;</span>
                <span class="s1">&#39;compatibility with Colander 0.9.9+.  In a future Colander &#39;</span>
                <span class="s1">&#39;version, the absence of this method will cause an &#39;</span>
                <span class="s1">&#39;exception.  Returning [] for compatibility although it &#39;</span>
                <span class="s1">&#39;may not be the right value.&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">cstruct_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove a subnode by name &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[:]):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get a subnode by name. &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_marker</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">_marker</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newnode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Replace a subnode by name.  ``newnode`` must be a SchemaNode.  If</span>
<span class="sd">        a subnode named ``name`` doesn&#39;t already exist, calling this method</span>
<span class="sd">        is the same as setting the node&#39;s name to ``name`` and calling the</span>
<span class="sd">        ``add`` method with the node (it will be appended to the children</span>
<span class="sd">        list).&quot;&quot;&quot;</span>
        <span class="n">newnode</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[:]):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                <span class="k">return</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterate over the children nodes of this schema node &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return True if subnode named ``name`` exists in this node &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_marker</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_marker</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1"> object at </span><span class="si">%d</span><span class="s1"> (named </span><span class="si">%s</span><span class="s1">)&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">raise_invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Raise a :exc:`colander.Invalid` exception with the message</span>
<span class="sd">        ``msg``.  ``node``, if supplied, should be an instance of a</span>
<span class="sd">        :class:`colander.SchemaNode`.  If it is not supplied, ``node`` will</span>
<span class="sd">        be this node.  Example usage::</span>

<span class="sd">            class CustomSchemaNode(SchemaNode):</span>
<span class="sd">                def validator(self, node, cstruct):</span>
<span class="sd">                    if cstruct != &#39;the_right_thing&#39;:</span>
<span class="sd">                        self.raise_invalid(&#39;Not the right thing&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_SchemaMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsattrs</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">clsattrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_SchemaNode</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">raw_title</span> <span class="ow">is</span> <span class="n">_marker</span><span class="p">:</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">value</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="n">nodes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__class_schema_nodes__</span> <span class="o">=</span> <span class="p">[</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="p">]</span>

        <span class="c1"># Combine all attrs from this class and its _SchemaNode superclasses.</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__all_schema_nodes__</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">):</span>
            <span class="n">csn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s1">&#39;__class_schema_nodes__&#39;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__all_schema_nodes__</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">csn</span><span class="p">)</span>

<span class="c1"># metaclass spelling compatibility across Python 2 and Python 3</span>
<span class="n">SchemaNode</span> <span class="o">=</span> <span class="n">_SchemaMeta</span><span class="p">(</span>
    <span class="s1">&#39;SchemaNode&#39;</span><span class="p">,</span>
    <span class="p">(</span><span class="n">_SchemaNode</span><span class="p">,),</span>
    <span class="p">{</span><span class="s1">&#39;__doc__&#39;</span><span class="p">:</span> <span class="n">_SchemaNode</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">}</span>
    <span class="p">)</span>

<span class="k">class</span> <span class="nc">Schema</span><span class="p">(</span><span class="n">SchemaNode</span><span class="p">):</span>
    <span class="n">schema_type</span> <span class="o">=</span> <span class="n">Mapping</span>

<span class="n">MappingSchema</span> <span class="o">=</span> <span class="n">Schema</span>

<span class="k">class</span> <span class="nc">TupleSchema</span><span class="p">(</span><span class="n">SchemaNode</span><span class="p">):</span>
    <span class="n">schema_type</span> <span class="o">=</span> <span class="n">Tuple</span>

<span class="k">class</span> <span class="nc">SequenceSchema</span><span class="p">(</span><span class="n">SchemaNode</span><span class="p">):</span>
    <span class="n">schema_type</span> <span class="o">=</span> <span class="n">Sequence</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">SchemaNode</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="s1">&#39;Sequence schemas must have exactly one child node&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clone the schema node and return the clone.  All subnodes</span>
<span class="sd">        are also cloned recursively.  Attributes present in node</span>
<span class="sd">        dictionaries are preserved.&quot;&quot;&quot;</span>

        <span class="c1"># Cloning a ``SequenceSchema`` doesn&#39;t work with ``_SchemaNode.clone``.</span>

        <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">)</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">attributes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">cloned</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cloned</span>

<span class="k">class</span> <span class="nc">deferred</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A decorator which can be used to define deferred schema values</span>
<span class="sd">    (missing values, widgets, validators, etc.)&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1">#non-function</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unflatten_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">,</span>
                       <span class="n">get_child</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rewrite_subpath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">get_child</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">get_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__getitem__</span>
    <span class="k">if</span> <span class="n">rewrite_subpath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">rewrite_subpath</span><span class="p">(</span><span class="n">subpath</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subpath</span>
    <span class="n">node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">node_name</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">node_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">prefix_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
    <span class="n">appstruct</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">subfstruct</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">subpaths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curname</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="n">node_name</span><span class="p">:</span>
            <span class="c1"># flattened structs contain non-leaf nodes which are ignored</span>
            <span class="c1"># during unflattening.</span>
            <span class="k">continue</span>
        <span class="k">assert</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">),</span> <span class="s2">&quot;Bad node: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">path</span>
        <span class="n">subpath</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">prefix_len</span><span class="p">:]</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">subpath</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subpath</span><span class="p">[:</span><span class="n">subpath</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subpath</span>
        <span class="k">if</span> <span class="n">curname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curname</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">curname</span><span class="p">:</span>
            <span class="n">subnode</span> <span class="o">=</span> <span class="n">get_child</span><span class="p">(</span><span class="n">curname</span><span class="p">)</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">curname</span><span class="p">]</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span>
                <span class="n">subnode</span><span class="p">,</span> <span class="n">subpaths</span><span class="p">,</span> <span class="n">subfstruct</span><span class="p">)</span>
            <span class="n">subfstruct</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">subpaths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">curname</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">subpath</span> <span class="o">=</span> <span class="n">rewrite_subpath</span><span class="p">(</span><span class="n">subpath</span><span class="p">)</span>
        <span class="n">subfstruct</span><span class="p">[</span><span class="n">subpath</span><span class="p">]</span> <span class="o">=</span> <span class="n">fstruct</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="n">subpaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subpath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">curname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">subnode</span> <span class="o">=</span> <span class="n">get_child</span><span class="p">(</span><span class="n">curname</span><span class="p">)</span>
        <span class="n">appstruct</span><span class="p">[</span><span class="n">curname</span><span class="p">]</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span>
            <span class="n">subnode</span><span class="p">,</span> <span class="n">subpaths</span><span class="p">,</span> <span class="n">subfstruct</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">appstruct</span>

<span class="k">class</span> <span class="nc">instantiate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A decorator which can be used to instantiate :class:`SchemaNode`</span>
<span class="sd">    elements inline within a class definition.</span>

<span class="sd">    All parameters passed to the decorator and passed along to the</span>
<span class="sd">    :class:`SchemaNode` during instantiation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">args</span><span class="p">,</span><span class="n">kw</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">class_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">class_</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction/introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/download.html">2. Downloading CamCOPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../client/client_installation.html">3. Installing and configuring the client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../client/client_using.html">4. Using the client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_front_end_general.html">5. Web site: general use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tasks/_tasks_by_category.html">6. Tasks in CamCOPS by category</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tasks/_tasks_all.html">7. All tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../client/client_troubleshooting.html">8. Troubleshooting client problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_installation.html">9. Installing CamCOPS on the server</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_configuration.html">10. Configuring the server</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_config_file.html">11. The CamCOPS server configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_front_end_admin.html">12. Web site: admin functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_command_line.html">13. CamCOPS command-line tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_troubleshooting.html">14. Troubleshooting server problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../licences/licences.html">15. Licences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">16. Developer notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/tcpip_ports.html">17. Common relevant TCP/IP ports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/linux_flavours.html">18. Linux flavours</a></li>
<li class="toctree-l1"><a class="reference internal" href="../autodoc/_index.html">19. Automatic documentation of core server source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">20. Change log/history</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq_known_problems.html">21. FAQ and known problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../to_do.html">22. Things to do</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wishlist.html">23. Wishlist and blue-sky thoughts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/local_info.html">24. Local configuration information</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CamCOPS 2.2.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2018, Rudolf Cardinal.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>