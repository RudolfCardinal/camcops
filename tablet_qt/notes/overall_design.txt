===============================================================================
CLIENT ARCHITECTURE
===============================================================================

- We can't run solely over the web; that would break when no Internet is
  available.

- It's very hard to get a good hybrid that will run over the web and on a
  standalone client; using Titanium, for example, was not easy and never ended
  up with a satisfactory web client.

- At which point, you may as well have a high-performance cross-platform client
  system, for low-performance devices, hence Qt/C++ (and there's potential to
  run even these over the web; e.g. Qt applications are starting [2017] to
  support being served over VNC).

===============================================================================
SERVER DATA DESIGN
===============================================================================

We're trying to satisfy quite a few constraints...

- Ability to enter data on tablet with less than the server's preferred ID
  requirements (hence the "upload" and "finalize" ID policies).

- Ability to run in minimal-ID and full-ID modes, as the server prefers (hence
  configurable ID.

- General principle of approaching a normalized database where possible, but
  with some exceptions:
    - the {device, era} server fields;
    - the _current field and related linking (history within the same table as
      data);
    - some extra copying of ID descriptions to "patient" record at upload, so
      that ID is absolutely secured if someone changes the ID descriptions.
      ... changed; this is a protection against administrator error, which is
          a pretty thin reason for some considerable de-normalization

- ALTERNATIVE HISTORY MODELS:
    - table with "current" field and history information
        - what we're using
        - some need to filter for research exports (ignoring non-current stuff)
    - history in separate shadow tables (profusion of tables; need to move
      data);
    - single giant audit table with fields like "table", "field", "value",
      "date"
    - bitemporal model, "date of entry" + "date we believe entry to be correct"
        https://www.simple-talk.com/sql/t-sql-programming/a-primer-on-managing-data-bitemporally/
        ... though picking "current" data requires a scan for maximum date
            per row
    - let's stick with what we have

- Ability to run without a server, or to switch servers, and to wipe data from
  the tablet after upload -- hence the server's extra {device, era} fields.
  The server maintains an integer PK system.

    - ALTERNATIVE KEY MODELS:
        - tablet becomes aware of server PK and uses that somehow
            - server has to report back PKs recordwise at upload
            - hard to switch servers
            - if modified version is uploaded, have to rewrite tablet keys
        - server maintains an additional PK system
            - server calculates these at upload
            - requires uploading in a way that respects dependencies (i.e.
              to upload a record B where B.a_fk = A.pk, A has to be uploaded
              first).
            - server needs to understand the details of all records - not just
              Patient references, but e.g. if a Trial references its Task, the
              server would have to cope.
    - Let's stick.
    - That means we have to cope with COMPOSITE KEYS.

===============================================================================
SERVER ORM AND WEB FRAMEWORK
===============================================================================

- Then, that leads to a decision about server-side database ORM.
    - Let's move away from mine; we want better cross-database support.
    - SQLAlchemy one obvious candidate.
        - Can be customized for our ISO date/time field.
        - Migration support worse than Django (at least in terms of convenience).
    - Django the other.
        - Can be customized for our ISO date/time field.
        - Historical weaknesses re composite keys.
            - We don't need composite primary keys, but we do want composite
              foreign keys.
        - Django's notes re composite PKs:
            https://code.djangoproject.com/wiki/MultipleColumnPrimaryKeys
        - There is external support:
            https://pypi.python.org/pypi/django-composite-foreignkey
        - Maybe we can't do this:
            patient = models.ForeignKey(Patient, ... where current and same device/era...)
          but we could do this:

            def patient() -> Optional[Patient]:
                if self.anonymous():
                    return None
                q = Patient.objects.filter(id__eq=self.patient_id)
                q = q.filter(_current__eq=True)
                q = q.filter(_device__eq=self._device)
                q = q.filter(_era__eq=self._era)
                return q[0] if q else None
                # http://stackoverflow.com/questions/1387727/checking-for-empty-queryset-in-django

            def tasks_where_patient_female() -> QuerySet:
                for TaskClass in all_non_anonymous_task_classes():
                    # ... mmm... this is less obvious
                    # ...

- In terms of a general database framework, Django is pretty good, and it's
  not clear that Pyramid is a huge improvement. Django also brings:
    - the excellent admin interface
    - good migrations
    - its debug toolbar
    - good documentation
    - we know it operates in the Windows (e.g. SQL Server) environment
    - field comments ("help_text" attribute)
        https://docs.djangoproject.com/en/dev/ref/models/fields/#help-text
    - permitted values ("choices")
    - note it has a preference for using "" not NULL for empty strings,
      but it can cope:
        https://docs.djangoproject.com/en/dev/ref/models/fields/#null
    - you can always use raw SQL
        https://docs.djangoproject.com/en/1.11/topics/db/sql

- What's the best with SQLAlchemy?
    - Flask? http://flask.pocoo.org/
    - Pyramid? https://trypyramid.com/

        migrations: SQLAlchemy/Alembic: http://alembic.zzzcomputing.com/en/latest/tutorial.html
        debug toolbar: http://docs.pylonsproject.org/projects/pyramid_debugtoolbar/en/latest/

- An option is Django with composite keys hacked in:
    http://django-composite-foreignkey.readthedocs.io/
    ... that might do the trick!

- Automatic forms are a Django strength, including the "choices" option on a
  model.
  Equivalent in SQLAlchemy:
    http://sqlalchemy-utils.readthedocs.io/en/latest/data_types.html#module-sqlalchemy_utils.types.choice
    ... Pyramid... Deform... Colander... it's all a bit DIY.

- So in essence we have the advantages with:

    ORM             SQLAlchemy e.g. Pyramid
            ... unless multiple column foreign keys are here?
            ... https://www.quora.com/Which-is-better-and-why-Djangos-ORM-or-SQLAlchemy
            ... aha!
                https://github.com/django/django/blob/master/django/db/models/fields/related.py
                ForeignObject
                "Abstraction of the ForeignKey relation to support multi-column relations."
                But in tests/foreign_objects/tests.py:
                # ForeignObject is not part of public API.

    Templates       Equal (can mix and match with either)
    Forms           Django
    Migrations      Django
    Config files    Pyramid (via .ini), probably, but Django .py can read .ini...
    Serving static                              Pyramid?
    Extending from an ad-hoc code structure     Pyramid

  Ultimately, MIGRATIONS ARE IMPORTANT. Django does these very well, including
  asking for default values for old records when you create a new NOT NULL
  column and so forth. Though you can customize the SQL...

- Note also that our direct-to-database approach for the current API (rather
  than the user front end) talks directly to databases without any object-
  oriented Task stuff. That would be significantly harder in Django than
  SQLAlchemy, becaues whereas SQLAlchemy has its Core underneath its ORM,
  the next thing under Django's ORM is raw (potentially backend-specific) SQL.

- One might also consider writing the server in C++ and sharing the task-
  specific code, which from that standpoint might be a considerable advantage.
  For example, the relevant task calculations would be automatically
  consistent. You could inspect the fancier result views on the client.
  Introspection would be harder.
  One would use it directly or (realistically) load it and proxy Apache to it.
  Stuff like ZIP file autocreation might be mildly fiddly once but not a
  problem. Templating was never a big problem to start with. One could somehow
  hack the DatabaseObject class so that it extended its fields when in use
  on the server (though that would need different PK systems; not entirely
  trivial). The major questions that occur to me are:
    - URL routing
    - multithreading/routing requests to lots of server threads
    - HTTP response objects
    - cross-platform/cross-backend database access
      ... Qt: ODBC support, MySQL, etc.
    - forms and other HTTP stuff
    - graphs
      ... Qt: https://doc.qt.io/qt-5/qtcharts-barchart-example.html
    - PDF generation
      ... Qt: https://stackoverflow.com/questions/10697228/converting-html-to-pdf-with-qt
    - automatic migrations
    - debugging
    - we're not in the same league of ease of use compared to e.g. the Django
      or Pyramid debug toolbar!
  Relevant C++ frameworks include
    - CppCMS
    - Cutelyst
    - ULib
    - Treefrog
    - etc.:
      https://en.wikipedia.org/wiki/Comparison_of_web_frameworks#C.2B.2B_2
  Ultimately, this is moving into sledgehammer-for-nut territory.
  (Note also that the primary advantage, the DRY basis of things like complex
  algorithms, is a potential safety decrement; doing it twice in two languages
  allows an additional cross-check during development, for this particular,
  in principle more safety-critical thing.)

- Other comparisons:
  - https://www.airpair.com/python/posts/django-flask-pyramid
  - https://www.codementor.io/sheena/django-vs-pyramid-python-framework-comparison-du107yb1c

- DECISION:
        SQLAlchemy
            - with a custom Column-derived type to check "permitted values" in
              a non-obligatory way
            - migrations: Alembic
        Pyramid
            - forms: Deform

- Pyramid tutorials of note
  - https://docs.pylonsproject.org/projects/pyramid-cookbook/en/latest/database/sqlalchemy.html


===============================================================================
THINGS TO AVOID
===============================================================================

- Hacking around with summary tables; the server shouldn't be adding tables
  dynamically. Create the data dumps dynamically (and convert to SQL for
  downloading if required).

    - To get Django to report table creation SQL: "django-admin sqlmigrate"
      does this on the command line, but also:
      https://docs.djangoproject.com/en/1.11/ref/schema-editor/
      ... could run this on an in-memory SQLite connection...

        with connection.schema_editor() as schema_editor:
            schema_editor.create_model(MyModel)  # uses the database
            # ... or:
            for field in SOME_FIELD_LIST:
                column_sql, params = schema_editor.column_sql(MyModel, field)

